// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/Kaiya/kafka-chan/kafkapb/kafka-chan.proto

package kafkapb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type KeywordFromType int32

const (
	KeywordFromType_KAFKA_MSG_KEY   KeywordFromType = 0
	KeywordFromType_KAFKA_MSG_VALUE KeywordFromType = 1
)

var KeywordFromType_name = map[int32]string{
	0: "KAFKA_MSG_KEY",
	1: "KAFKA_MSG_VALUE",
}

var KeywordFromType_value = map[string]int32{
	"KAFKA_MSG_KEY":   0,
	"KAFKA_MSG_VALUE": 1,
}

func (x KeywordFromType) String() string {
	return proto.EnumName(KeywordFromType_name, int32(x))
}

func (KeywordFromType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{0}
}

type QueryMsgByKeywordRequest struct {
	KafkaTopic           string          `protobuf:"bytes,1,opt,name=kafkaTopic,proto3" json:"kafkaTopic,omitempty"`
	Partition            int32           `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Keyword              string          `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	KeywordFrom          KeywordFromType `protobuf:"varint,4,opt,name=keyword_from,json=keywordFrom,proto3,enum=kafkapb.KeywordFromType" json:"keyword_from,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueryMsgByKeywordRequest) Reset()         { *m = QueryMsgByKeywordRequest{} }
func (m *QueryMsgByKeywordRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMsgByKeywordRequest) ProtoMessage()    {}
func (*QueryMsgByKeywordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{0}
}

func (m *QueryMsgByKeywordRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryMsgByKeywordRequest.Unmarshal(m, b)
}
func (m *QueryMsgByKeywordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryMsgByKeywordRequest.Marshal(b, m, deterministic)
}
func (m *QueryMsgByKeywordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMsgByKeywordRequest.Merge(m, src)
}
func (m *QueryMsgByKeywordRequest) XXX_Size() int {
	return xxx_messageInfo_QueryMsgByKeywordRequest.Size(m)
}
func (m *QueryMsgByKeywordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMsgByKeywordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMsgByKeywordRequest proto.InternalMessageInfo

func (m *QueryMsgByKeywordRequest) GetKafkaTopic() string {
	if m != nil {
		return m.KafkaTopic
	}
	return ""
}

func (m *QueryMsgByKeywordRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *QueryMsgByKeywordRequest) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *QueryMsgByKeywordRequest) GetKeywordFrom() KeywordFromType {
	if m != nil {
		return m.KeywordFrom
	}
	return KeywordFromType_KAFKA_MSG_KEY
}

type QueryMsgByKeywordReply struct {
	MsgJson              string   `protobuf:"bytes,1,opt,name=msg_json,json=msgJson,proto3" json:"msg_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryMsgByKeywordReply) Reset()         { *m = QueryMsgByKeywordReply{} }
func (m *QueryMsgByKeywordReply) String() string { return proto.CompactTextString(m) }
func (*QueryMsgByKeywordReply) ProtoMessage()    {}
func (*QueryMsgByKeywordReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{1}
}

func (m *QueryMsgByKeywordReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryMsgByKeywordReply.Unmarshal(m, b)
}
func (m *QueryMsgByKeywordReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryMsgByKeywordReply.Marshal(b, m, deterministic)
}
func (m *QueryMsgByKeywordReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMsgByKeywordReply.Merge(m, src)
}
func (m *QueryMsgByKeywordReply) XXX_Size() int {
	return xxx_messageInfo_QueryMsgByKeywordReply.Size(m)
}
func (m *QueryMsgByKeywordReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMsgByKeywordReply.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMsgByKeywordReply proto.InternalMessageInfo

func (m *QueryMsgByKeywordReply) GetMsgJson() string {
	if m != nil {
		return m.MsgJson
	}
	return ""
}

type ProduceMsgToTopicRequest struct {
	KafkaTopic           string   `protobuf:"bytes,1,opt,name=kafkaTopic,proto3" json:"kafkaTopic,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Key                  string   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	MsgJson              string   `protobuf:"bytes,4,opt,name=msg_json,json=msgJson,proto3" json:"msg_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProduceMsgToTopicRequest) Reset()         { *m = ProduceMsgToTopicRequest{} }
func (m *ProduceMsgToTopicRequest) String() string { return proto.CompactTextString(m) }
func (*ProduceMsgToTopicRequest) ProtoMessage()    {}
func (*ProduceMsgToTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{2}
}

func (m *ProduceMsgToTopicRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProduceMsgToTopicRequest.Unmarshal(m, b)
}
func (m *ProduceMsgToTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProduceMsgToTopicRequest.Marshal(b, m, deterministic)
}
func (m *ProduceMsgToTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProduceMsgToTopicRequest.Merge(m, src)
}
func (m *ProduceMsgToTopicRequest) XXX_Size() int {
	return xxx_messageInfo_ProduceMsgToTopicRequest.Size(m)
}
func (m *ProduceMsgToTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProduceMsgToTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProduceMsgToTopicRequest proto.InternalMessageInfo

func (m *ProduceMsgToTopicRequest) GetKafkaTopic() string {
	if m != nil {
		return m.KafkaTopic
	}
	return ""
}

func (m *ProduceMsgToTopicRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ProduceMsgToTopicRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ProduceMsgToTopicRequest) GetMsgJson() string {
	if m != nil {
		return m.MsgJson
	}
	return ""
}

type ProduceMsgToTopicReply struct {
	Ok                   bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProduceMsgToTopicReply) Reset()         { *m = ProduceMsgToTopicReply{} }
func (m *ProduceMsgToTopicReply) String() string { return proto.CompactTextString(m) }
func (*ProduceMsgToTopicReply) ProtoMessage()    {}
func (*ProduceMsgToTopicReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{3}
}

func (m *ProduceMsgToTopicReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProduceMsgToTopicReply.Unmarshal(m, b)
}
func (m *ProduceMsgToTopicReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProduceMsgToTopicReply.Marshal(b, m, deterministic)
}
func (m *ProduceMsgToTopicReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProduceMsgToTopicReply.Merge(m, src)
}
func (m *ProduceMsgToTopicReply) XXX_Size() int {
	return xxx_messageInfo_ProduceMsgToTopicReply.Size(m)
}
func (m *ProduceMsgToTopicReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProduceMsgToTopicReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProduceMsgToTopicReply proto.InternalMessageInfo

func (m *ProduceMsgToTopicReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type MakeMemoryLRUCacheRequest struct {
	KafkaTopic           string   `protobuf:"bytes,1,opt,name=kafkaTopic,proto3" json:"kafkaTopic,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MakeMemoryLRUCacheRequest) Reset()         { *m = MakeMemoryLRUCacheRequest{} }
func (m *MakeMemoryLRUCacheRequest) String() string { return proto.CompactTextString(m) }
func (*MakeMemoryLRUCacheRequest) ProtoMessage()    {}
func (*MakeMemoryLRUCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{4}
}

func (m *MakeMemoryLRUCacheRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MakeMemoryLRUCacheRequest.Unmarshal(m, b)
}
func (m *MakeMemoryLRUCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MakeMemoryLRUCacheRequest.Marshal(b, m, deterministic)
}
func (m *MakeMemoryLRUCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MakeMemoryLRUCacheRequest.Merge(m, src)
}
func (m *MakeMemoryLRUCacheRequest) XXX_Size() int {
	return xxx_messageInfo_MakeMemoryLRUCacheRequest.Size(m)
}
func (m *MakeMemoryLRUCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MakeMemoryLRUCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MakeMemoryLRUCacheRequest proto.InternalMessageInfo

func (m *MakeMemoryLRUCacheRequest) GetKafkaTopic() string {
	if m != nil {
		return m.KafkaTopic
	}
	return ""
}

func (m *MakeMemoryLRUCacheRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type MakeMemoryLRUCacheReply struct {
	Ok                   bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MakeMemoryLRUCacheReply) Reset()         { *m = MakeMemoryLRUCacheReply{} }
func (m *MakeMemoryLRUCacheReply) String() string { return proto.CompactTextString(m) }
func (*MakeMemoryLRUCacheReply) ProtoMessage()    {}
func (*MakeMemoryLRUCacheReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{5}
}

func (m *MakeMemoryLRUCacheReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MakeMemoryLRUCacheReply.Unmarshal(m, b)
}
func (m *MakeMemoryLRUCacheReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MakeMemoryLRUCacheReply.Marshal(b, m, deterministic)
}
func (m *MakeMemoryLRUCacheReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MakeMemoryLRUCacheReply.Merge(m, src)
}
func (m *MakeMemoryLRUCacheReply) XXX_Size() int {
	return xxx_messageInfo_MakeMemoryLRUCacheReply.Size(m)
}
func (m *MakeMemoryLRUCacheReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MakeMemoryLRUCacheReply.DiscardUnknown(m)
}

var xxx_messageInfo_MakeMemoryLRUCacheReply proto.InternalMessageInfo

func (m *MakeMemoryLRUCacheReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type QueryMsgByOffsetReply struct {
	MsgJson              string   `protobuf:"bytes,1,opt,name=msg_json,json=msgJson,proto3" json:"msg_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryMsgByOffsetReply) Reset()         { *m = QueryMsgByOffsetReply{} }
func (m *QueryMsgByOffsetReply) String() string { return proto.CompactTextString(m) }
func (*QueryMsgByOffsetReply) ProtoMessage()    {}
func (*QueryMsgByOffsetReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{6}
}

func (m *QueryMsgByOffsetReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryMsgByOffsetReply.Unmarshal(m, b)
}
func (m *QueryMsgByOffsetReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryMsgByOffsetReply.Marshal(b, m, deterministic)
}
func (m *QueryMsgByOffsetReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMsgByOffsetReply.Merge(m, src)
}
func (m *QueryMsgByOffsetReply) XXX_Size() int {
	return xxx_messageInfo_QueryMsgByOffsetReply.Size(m)
}
func (m *QueryMsgByOffsetReply) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMsgByOffsetReply.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMsgByOffsetReply proto.InternalMessageInfo

func (m *QueryMsgByOffsetReply) GetMsgJson() string {
	if m != nil {
		return m.MsgJson
	}
	return ""
}

type QueryMsgByOffsetRequest struct {
	KafkaTopic           string   `protobuf:"bytes,1,opt,name=kafkaTopic,proto3" json:"kafkaTopic,omitempty"`
	Partition            int64    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Offset               int64    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryMsgByOffsetRequest) Reset()         { *m = QueryMsgByOffsetRequest{} }
func (m *QueryMsgByOffsetRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMsgByOffsetRequest) ProtoMessage()    {}
func (*QueryMsgByOffsetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b49be04aedd6e87b, []int{7}
}

func (m *QueryMsgByOffsetRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryMsgByOffsetRequest.Unmarshal(m, b)
}
func (m *QueryMsgByOffsetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryMsgByOffsetRequest.Marshal(b, m, deterministic)
}
func (m *QueryMsgByOffsetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMsgByOffsetRequest.Merge(m, src)
}
func (m *QueryMsgByOffsetRequest) XXX_Size() int {
	return xxx_messageInfo_QueryMsgByOffsetRequest.Size(m)
}
func (m *QueryMsgByOffsetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMsgByOffsetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMsgByOffsetRequest proto.InternalMessageInfo

func (m *QueryMsgByOffsetRequest) GetKafkaTopic() string {
	if m != nil {
		return m.KafkaTopic
	}
	return ""
}

func (m *QueryMsgByOffsetRequest) GetPartition() int64 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *QueryMsgByOffsetRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterEnum("kafkapb.KeywordFromType", KeywordFromType_name, KeywordFromType_value)
	proto.RegisterType((*QueryMsgByKeywordRequest)(nil), "kafkapb.QueryMsgByKeywordRequest")
	proto.RegisterType((*QueryMsgByKeywordReply)(nil), "kafkapb.QueryMsgByKeywordReply")
	proto.RegisterType((*ProduceMsgToTopicRequest)(nil), "kafkapb.ProduceMsgToTopicRequest")
	proto.RegisterType((*ProduceMsgToTopicReply)(nil), "kafkapb.ProduceMsgToTopicReply")
	proto.RegisterType((*MakeMemoryLRUCacheRequest)(nil), "kafkapb.MakeMemoryLRUCacheRequest")
	proto.RegisterType((*MakeMemoryLRUCacheReply)(nil), "kafkapb.MakeMemoryLRUCacheReply")
	proto.RegisterType((*QueryMsgByOffsetReply)(nil), "kafkapb.QueryMsgByOffsetReply")
	proto.RegisterType((*QueryMsgByOffsetRequest)(nil), "kafkapb.QueryMsgByOffsetRequest")
}

func init() {
	proto.RegisterFile("github.com/Kaiya/kafka-chan/kafkapb/kafka-chan.proto", fileDescriptor_b49be04aedd6e87b)
}

var fileDescriptor_b49be04aedd6e87b = []byte{
	// 472 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x51, 0x6f, 0x12, 0x41,
	0x10, 0xc7, 0x39, 0xa8, 0xa5, 0x8c, 0xda, 0xd2, 0x35, 0xd2, 0x2b, 0x31, 0xf5, 0xbc, 0x27, 0x34,
	0x91, 0x26, 0xd4, 0x17, 0xe3, 0x13, 0x36, 0xad, 0x89, 0xd7, 0x8b, 0x7a, 0xd2, 0x26, 0x24, 0x26,
	0x64, 0xb9, 0x2e, 0xc7, 0xb9, 0xbd, 0x9b, 0x73, 0xf7, 0x88, 0xd9, 0x0f, 0xe0, 0xe7, 0xf1, 0xe3,
	0xf9, 0x6a, 0x58, 0xce, 0x72, 0x94, 0x03, 0x93, 0x86, 0xb7, 0xdd, 0x61, 0xe6, 0xbf, 0xbf, 0x99,
	0xf9, 0x73, 0xf0, 0x26, 0x08, 0xd3, 0xf1, 0x64, 0xd8, 0xf6, 0x31, 0x3a, 0x76, 0x68, 0xa8, 0xe8,
	0x31, 0xa7, 0x23, 0x4e, 0x5f, 0xfb, 0x63, 0x1a, 0xcf, 0x8e, 0xc9, 0x30, 0x17, 0x6a, 0x27, 0x02,
	0x53, 0x24, 0xd5, 0xec, 0x17, 0xfb, 0xb7, 0x01, 0xe6, 0x97, 0x09, 0x13, 0xca, 0x95, 0xc1, 0x7b,
	0xe5, 0x30, 0xf5, 0x13, 0xc5, 0xb5, 0xc7, 0x7e, 0x4c, 0x98, 0x4c, 0xc9, 0x11, 0x80, 0xce, 0xeb,
	0x61, 0x12, 0xfa, 0xa6, 0x61, 0x19, 0xad, 0x9a, 0x97, 0x8b, 0x90, 0x67, 0x50, 0x4b, 0xa8, 0x48,
	0xc3, 0x34, 0xc4, 0xd8, 0x2c, 0x5b, 0x46, 0xeb, 0x81, 0x37, 0x0f, 0x10, 0x13, 0xaa, 0x7c, 0xa6,
	0x67, 0x56, 0x74, 0xe9, 0xbf, 0x2b, 0x79, 0x07, 0x8f, 0xb2, 0xe3, 0x60, 0x24, 0x30, 0x32, 0xb7,
	0x2c, 0xa3, 0xb5, 0xdb, 0x31, 0xdb, 0x19, 0x54, 0x3b, 0xc3, 0x38, 0x17, 0x18, 0xf5, 0x54, 0xc2,
	0xbc, 0x87, 0x7c, 0x1e, 0xb0, 0x4f, 0xa0, 0x51, 0x00, 0x9c, 0xdc, 0x28, 0x72, 0x08, 0x3b, 0x91,
	0x0c, 0x06, 0xdf, 0x25, 0xc6, 0x19, 0x6c, 0x35, 0x92, 0xc1, 0x47, 0x89, 0xb1, 0xfd, 0xcb, 0x00,
	0xf3, 0xb3, 0xc0, 0xeb, 0x89, 0xcf, 0x5c, 0x19, 0xf4, 0x50, 0xf3, 0x6f, 0xa6, 0xcd, 0x3a, 0x54,
	0x38, 0x53, 0x59, 0x8b, 0xd3, 0xe3, 0x02, 0xc7, 0xd6, 0x22, 0x47, 0x0b, 0x1a, 0x05, 0x18, 0x53,
	0xf8, 0x5d, 0x28, 0x23, 0xd7, 0x8f, 0xef, 0x78, 0x65, 0xe4, 0x76, 0x1f, 0x0e, 0x5d, 0xca, 0x99,
	0xcb, 0x22, 0x14, 0xea, 0xc2, 0xbb, 0x3c, 0xa5, 0xfe, 0x98, 0x6d, 0x84, 0xd8, 0x7e, 0x09, 0x07,
	0x45, 0xd2, 0x45, 0x14, 0x1d, 0x78, 0x3a, 0x1f, 0xf6, 0xa7, 0xd1, 0x48, 0xb2, 0xf4, 0xbf, 0xb3,
	0x46, 0x38, 0x58, 0xae, 0xb9, 0x27, 0x77, 0x25, 0x3f, 0xe9, 0x06, 0x6c, 0xa3, 0x96, 0xd3, 0xc3,
	0xae, 0x78, 0xd9, 0xed, 0xd5, 0x5b, 0xd8, 0xbb, 0xe3, 0x18, 0xb2, 0x0f, 0x8f, 0x9d, 0xee, 0xb9,
	0xd3, 0x1d, 0xb8, 0x5f, 0x3f, 0x0c, 0x9c, 0xb3, 0x7e, 0xbd, 0x44, 0x9e, 0xc0, 0xde, 0x3c, 0x74,
	0xd5, 0xbd, 0xb8, 0x3c, 0xab, 0x1b, 0x9d, 0x3f, 0x65, 0xa8, 0x39, 0xd3, 0xf7, 0x4f, 0xc7, 0x34,
	0x26, 0x7d, 0xd8, 0x5f, 0xb2, 0x16, 0x79, 0x71, 0x6b, 0xcb, 0x55, 0xff, 0x93, 0xe6, 0xf3, 0x75,
	0x29, 0xc9, 0x8d, 0xb2, 0x4b, 0x53, 0xe9, 0xa5, 0xc5, 0xe7, 0xa4, 0x57, 0x79, 0x33, 0x27, 0x5d,
	0xec, 0x1b, 0xbb, 0x44, 0xbe, 0x01, 0x59, 0x5e, 0x27, 0xb1, 0x6f, 0x0b, 0x57, 0xda, 0xa8, 0x69,
	0xad, 0xcd, 0x99, 0xa9, 0x5f, 0x41, 0xfd, 0xee, 0x36, 0x89, 0x55, 0xd0, 0xef, 0xc2, 0xa2, 0x9b,
	0x47, 0x6b, 0x32, 0xb4, 0xee, 0x70, 0x5b, 0x7f, 0x88, 0x4e, 0xfe, 0x06, 0x00, 0x00, 0xff, 0xff,
	0xfa, 0x7b, 0xf0, 0x77, 0xc0, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KafkaChanClient is the client API for KafkaChan service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KafkaChanClient interface {
	QueryMsgByKeyword(ctx context.Context, in *QueryMsgByKeywordRequest, opts ...grpc.CallOption) (*QueryMsgByKeywordReply, error)
	ProduceMsgToTopic(ctx context.Context, in *ProduceMsgToTopicRequest, opts ...grpc.CallOption) (*ProduceMsgToTopicReply, error)
	MakeMemoryLRUCache(ctx context.Context, in *MakeMemoryLRUCacheRequest, opts ...grpc.CallOption) (*MakeMemoryLRUCacheReply, error)
	QueryMsgByOffset(ctx context.Context, in *QueryMsgByOffsetRequest, opts ...grpc.CallOption) (*QueryMsgByOffsetReply, error)
}

type kafkaChanClient struct {
	cc *grpc.ClientConn
}

func NewKafkaChanClient(cc *grpc.ClientConn) KafkaChanClient {
	return &kafkaChanClient{cc}
}

func (c *kafkaChanClient) QueryMsgByKeyword(ctx context.Context, in *QueryMsgByKeywordRequest, opts ...grpc.CallOption) (*QueryMsgByKeywordReply, error) {
	out := new(QueryMsgByKeywordReply)
	err := c.cc.Invoke(ctx, "/kafkapb.KafkaChan/QueryMsgByKeyword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaChanClient) ProduceMsgToTopic(ctx context.Context, in *ProduceMsgToTopicRequest, opts ...grpc.CallOption) (*ProduceMsgToTopicReply, error) {
	out := new(ProduceMsgToTopicReply)
	err := c.cc.Invoke(ctx, "/kafkapb.KafkaChan/ProduceMsgToTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaChanClient) MakeMemoryLRUCache(ctx context.Context, in *MakeMemoryLRUCacheRequest, opts ...grpc.CallOption) (*MakeMemoryLRUCacheReply, error) {
	out := new(MakeMemoryLRUCacheReply)
	err := c.cc.Invoke(ctx, "/kafkapb.KafkaChan/MakeMemoryLRUCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kafkaChanClient) QueryMsgByOffset(ctx context.Context, in *QueryMsgByOffsetRequest, opts ...grpc.CallOption) (*QueryMsgByOffsetReply, error) {
	out := new(QueryMsgByOffsetReply)
	err := c.cc.Invoke(ctx, "/kafkapb.KafkaChan/QueryMsgByOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KafkaChanServer is the server API for KafkaChan service.
type KafkaChanServer interface {
	QueryMsgByKeyword(context.Context, *QueryMsgByKeywordRequest) (*QueryMsgByKeywordReply, error)
	ProduceMsgToTopic(context.Context, *ProduceMsgToTopicRequest) (*ProduceMsgToTopicReply, error)
	MakeMemoryLRUCache(context.Context, *MakeMemoryLRUCacheRequest) (*MakeMemoryLRUCacheReply, error)
	QueryMsgByOffset(context.Context, *QueryMsgByOffsetRequest) (*QueryMsgByOffsetReply, error)
}

// UnimplementedKafkaChanServer can be embedded to have forward compatible implementations.
type UnimplementedKafkaChanServer struct {
}

func (*UnimplementedKafkaChanServer) QueryMsgByKeyword(ctx context.Context, req *QueryMsgByKeywordRequest) (*QueryMsgByKeywordReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMsgByKeyword not implemented")
}
func (*UnimplementedKafkaChanServer) ProduceMsgToTopic(ctx context.Context, req *ProduceMsgToTopicRequest) (*ProduceMsgToTopicReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProduceMsgToTopic not implemented")
}
func (*UnimplementedKafkaChanServer) MakeMemoryLRUCache(ctx context.Context, req *MakeMemoryLRUCacheRequest) (*MakeMemoryLRUCacheReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeMemoryLRUCache not implemented")
}
func (*UnimplementedKafkaChanServer) QueryMsgByOffset(ctx context.Context, req *QueryMsgByOffsetRequest) (*QueryMsgByOffsetReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMsgByOffset not implemented")
}

func RegisterKafkaChanServer(s *grpc.Server, srv KafkaChanServer) {
	s.RegisterService(&_KafkaChan_serviceDesc, srv)
}

func _KafkaChan_QueryMsgByKeyword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMsgByKeywordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaChanServer).QueryMsgByKeyword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kafkapb.KafkaChan/QueryMsgByKeyword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaChanServer).QueryMsgByKeyword(ctx, req.(*QueryMsgByKeywordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaChan_ProduceMsgToTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProduceMsgToTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaChanServer).ProduceMsgToTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kafkapb.KafkaChan/ProduceMsgToTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaChanServer).ProduceMsgToTopic(ctx, req.(*ProduceMsgToTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaChan_MakeMemoryLRUCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakeMemoryLRUCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaChanServer).MakeMemoryLRUCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kafkapb.KafkaChan/MakeMemoryLRUCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaChanServer).MakeMemoryLRUCache(ctx, req.(*MakeMemoryLRUCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KafkaChan_QueryMsgByOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMsgByOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafkaChanServer).QueryMsgByOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kafkapb.KafkaChan/QueryMsgByOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafkaChanServer).QueryMsgByOffset(ctx, req.(*QueryMsgByOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _KafkaChan_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kafkapb.KafkaChan",
	HandlerType: (*KafkaChanServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryMsgByKeyword",
			Handler:    _KafkaChan_QueryMsgByKeyword_Handler,
		},
		{
			MethodName: "ProduceMsgToTopic",
			Handler:    _KafkaChan_ProduceMsgToTopic_Handler,
		},
		{
			MethodName: "MakeMemoryLRUCache",
			Handler:    _KafkaChan_MakeMemoryLRUCache_Handler,
		},
		{
			MethodName: "QueryMsgByOffset",
			Handler:    _KafkaChan_QueryMsgByOffset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/Kaiya/kafka-chan/kafkapb/kafka-chan.proto",
}
